//
//  MiniPlayerViewController.swift
//  Dotify
//
//  Created Lucas Pham on 7/15/19.
//  Copyright © 2019 Vinova. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import AVFoundation

class MiniPlayerViewController: UIViewController, MiniPlayerViewProtocol {
    @IBOutlet weak var mainView: UIView!
    @IBOutlet weak var miniPlayerView: UIView!
    @IBOutlet weak var musicImgView: UIImageView!
    @IBOutlet weak var playPauseButton: UIButton!
    @IBOutlet weak var songTitleLabel: UILabel!
    @IBOutlet weak var artistNameLabel: UILabel!
    @IBOutlet weak var thumbImageView: UIImageView!
    @IBOutlet weak var hamburgerView: HamburgerView!
    @IBOutlet weak var blackView: UIView!
    @IBOutlet weak var blackViewWidth: NSLayoutConstraint!
    @IBOutlet weak var hamburgerLeading: NSLayoutConstraint!
    
    var tapGestureMiniPlayer: UITapGestureRecognizer?
    var audioPlaying = AudioPlaying.ins
    var hamburgerWidth = 300
    var isShowHamburger = false
    var tapGestureMainView: UITapGestureRecognizer?
    var audioPlayer = AudioPlayerRouter.createModule()
    var presenter: MiniPlayerPresenterProtocol?
    var delegate: MiniPlayerDelegate?
    var pageVC: UIPageViewController?
    var listVC: [UIViewController]?
    
    var rootViewController: UIViewController? {
        didSet {
            let navVC = self.rootViewController as? UINavigationController
            let rootVC = navVC?.visibleViewController as? DoomVC
            rootVC?.delegate = self
            
        }
    }
    
	override func viewDidLoad() {
        super.viewDidLoad()
        setUpView()
        addChildVC(vc: rootViewController ?? UIViewController())
        tapGestureMiniPlayer = UITapGestureRecognizer(target: self, action: #selector(didTapMiniPlayer))
        
        hamburgerLeading.constant = -view.frame.width
        blackViewWidth.constant = view.frame.width - CGFloat(hamburgerWidth)
        blackView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(didTapMainView)))
        hamburgerView.delegate = self
        
        audioPlaying.listID = audioPlaying.originListID
        
        listVC = [SongCommentRouter.createModule(), audioPlayer]
        pageVC = UIPageViewController(transitionStyle: .scroll, navigationOrientation: .horizontal, options: nil)
        pageVC?.setViewControllers([listVC![1]], direction: .forward, animated: true, completion: nil)
        pageVC?.dataSource = self
        
        do {
            guard let userData = UserDefaults.standard.data(forKey: "user") else { return }
            let user = try JSONDecoder().decode(User.self, from: userData)
            hamburgerView.user = user
            
            guard let listSongData = UserDefaults.standard.data(forKey: "list_song_id") else { return }
            let songIds = try JSONDecoder().decode(Array<String>.self, from: listSongData)
            initPlayer(listID: songIds, index: 0)
        } catch {
            print(error.localizedDescription)
        }
        
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(true)
        audioPlayer.mainVC = self
        navigationController?.navigationBar.isHidden = true
        updatePlayPauseButton()
    }
    
    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        guard context == &audioPlaying.playerItemContext else {
            super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
            return
        }
        if keyPath == #keyPath(AVPlayerItem.status) {
            let status: AVPlayerItem.Status
            if let statusNumber = change?[.newKey] as? NSNumber {
                status = AVPlayerItem.Status(rawValue: statusNumber.intValue)!
            } else {
                status = .unknown
            }
            
            switch status {
            case .readyToPlay:
                playPauseButton.isEnabled = true
                
            case .unknown:
                let alertVC = UIAlertController(title: "Error", message: "Unknown error", preferredStyle: .alert)
                alertVC.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                present(alertVC, animated: true, completion: nil)
                playPauseButton.isEnabled = false
                
            case .failed:
                let alertVC = UIAlertController(title: "Error", message: "Player has failed", preferredStyle: .alert)
                alertVC.addAction(UIAlertAction(title: "OK", style: .default, handler: nil))
                present(alertVC, animated: true, completion: nil)
                playPauseButton.isEnabled = false
                
            @unknown default:
                break
            }
        }
    }
    //MARK: Action
    @IBAction func didTapPlayPause(_ sender: Any) {
        if isShowHamburger {
            toggleHamburgerView()
            return
        }
        if audioPlaying.isPlaying {
            pauseMusic()
        } else {
            playMusic()
        }
    }
    
    //MARK: Setup view
    func setUpView(){
        musicImgView.layer.cornerRadius = musicImgView.frame.height / 2
        playPauseButton.isEnabled = false
        playPauseButton.setImage( audioPlaying.isPlaying ? #imageLiteral(resourceName: "pause-small").withRenderingMode(.alwaysOriginal) : #imageLiteral(resourceName: "play_small").withRenderingMode(.alwaysOriginal), for: .normal)
    }
    func setUpMiniPlayer(song: Song){
        songTitleLabel.text = song.name
        artistNameLabel.text = song.artist?.name!
        thumbImageView.sd_setImage(with: URL(string: song.imageUrl!)!, completed: nil)
    }
    func updatePlayPauseButton() {
        let isPlaying = audioPlaying.isPlaying
        delegate?.didTapPlayButton(isPlaying: isPlaying)
        playPauseButton.setImage(isPlaying ? #imageLiteral(resourceName: "pause-small").withRenderingMode(.alwaysOriginal) : #imageLiteral(resourceName: "play_small").withRenderingMode(.alwaysOriginal)  , for: .normal)
    }
    private func addChildVC(vc: UIViewController){
        mainView.subviews.forEach { $0.removeFromSuperview() }
        rootViewController = vc
        addChild(rootViewController!)
        mainView.addSubview(rootViewController!.view)
        rootViewController!.view.frame = mainView.bounds
        rootViewController!.view.autoresizingMask = [.flexibleWidth, .flexibleHeight]
        rootViewController!.didMove(toParent: self)
    }
}

import MediaPlayer
//MARK: Control music
extension MiniPlayerViewController {
    func didTapMusic(listID: [String], index: Int){
        if audioPlaying.downloadingStatus() { return }
        pauseMusic()
        
        miniPlayerView.removeGestureRecognizer(tapGestureMiniPlayer!)
        audioPlaying.setDownloadStatus(isOn: true)
        audioPlaying.setUpListID(listID: listID, index: index)
        audioPlaying.seekToTime(second: 0)
        processMusic(showPlayer: true) {
            self.presenter?.writeListSong(ids: listID)
            self.audioPlaying.setDownloadStatus(isOn: false)
            self.playMusic()
            
            let commandCenter = MPRemoteCommandCenter.shared()
            commandCenter.previousTrackCommand.isEnabled = true
            commandCenter.previousTrackCommand.addTarget(self, action: #selector(self.preTrack))
            
            commandCenter.nextTrackCommand.isEnabled = true
            commandCenter.nextTrackCommand.addTarget(self, action: #selector(self.nextTrack))
            
            commandCenter.playCommand.isEnabled = true
            commandCenter.playCommand.addTarget(self, action: #selector(self.playTrack))
            
            commandCenter.pauseCommand.isEnabled = true
            commandCenter.pauseCommand.addTarget(self, action: #selector(self.pauseMusic))
            
            self.audioPlaying.updateMPRemotePlayer()
        }
    }
    @objc func preTrack(){ goToMusic(next: false) }
    @objc func nextTrack() { goToMusic(next: true) }
    @objc func playTrack() { playMusic() }
    @objc func pauseTrack() { pauseMusic() }
    func initPlayer(listID: [String], index: Int){
        if audioPlaying.downloadingStatus() { return }
        pauseMusic()
        audioPlaying.setShuffleState(.OFF)
        audioPlaying.setDownloadStatus(isOn: true)
        miniPlayerView.removeGestureRecognizer(tapGestureMiniPlayer!)
        audioPlaying.setUpListID(listID: listID, index: index)
        processMusic {
            self.presenter?.writeListSong(ids: listID)
            self.miniPlayerView.addGestureRecognizer(self.tapGestureMiniPlayer!)
            self.audioPlaying.setDownloadStatus(isOn: false)
        }
    }
    
    func processMusic(showPlayer: Bool = false, completion: @escaping () -> Void  ){
        presenter?.getSongContent(listID: audioPlaying.listID, indexPlaying: audioPlaying.indexPlaying, { (song) in
            self.audioPlaying.song = song
            self.setUpMiniPlayer(song: song)
            if (self.audioPlaying.isPlayerLoaded) {
                self.audioPlayer.setUpMusicInfo()
            }
            self.miniPlayerView.addGestureRecognizer(self.tapGestureMiniPlayer!)
            if showPlayer { self.showPlayer() }
        }, { (url, error) in
            guard error == nil else { fatalError("Error while get URL") }
            self.audioPlaying.setUpPlayer(url: url, { (status) in
                self.audioPlaying.song?.link = url.absoluteString
                NotificationCenter.default.addObserver(self, selector: #selector(self.playerDidPlayEnd), name: .AVPlayerItemDidPlayToEndTime, object: self.audioPlaying.player.currentItem)
                self.audioPlaying.player.addObserver(self, forKeyPath: #keyPath(AVPlayerItem.status), options: [.old, .new], context: &self.audioPlaying.playerItemContext)
                completion()
            })
        })
    }
    func showPlayer(){
        let player = UINavigationController(rootViewController: pageVC!)
        self.present(player, animated: true, completion: nil)
    }
    func playMusic(){
        audioPlaying.playPlayer()
        updatePlayPauseButton()
        if audioPlaying.isPlayerLoaded { audioPlayer.updateViewWhenTogglePlay() }
    }
    @objc func pauseMusic(){
        audioPlaying.pausePlayer()
        updatePlayPauseButton()
        if audioPlaying.isPlayerLoaded { audioPlayer.updateViewWhenTogglePlay() }
    }
    func goToMusic(next: Bool){
        var index = audioPlaying.indexPlaying
        index += next ? 1 : -1
        if index < 0 || index >= audioPlaying.listID.count { return }
        audioPlaying.indexPlaying = index
        pauseMusic()
        audioPlaying.seekToTime(second: 0)
        processMusic {
            self.playMusic()
            if self.audioPlaying.isPlayerLoaded {
                self.audioPlayer.setUpView()
                self.audioPlayer.setUpMusicInfo()
                self.audioPlayer.updateViewWhenTogglePlay()
            }
        }
    }
    func goToMusic(index: Int){
        audioPlaying.indexPlaying = index
        if audioPlaying.indexPlaying < 0 || audioPlaying.indexPlaying >= audioPlaying.listID.count { return }
        pauseMusic()
        audioPlaying.seekToTime(second: 0)
        processMusic {
            self.playMusic()
            if self.audioPlaying.isPlayerLoaded {
                self.audioPlayer.setUpView()
                self.audioPlayer.setUpMusicInfo()
                self.audioPlayer.updateViewWhenTogglePlay()
            }
        }
    }
    //MARK: Selector function
    @objc func didTapMiniPlayer() {
        if audioPlaying.player.status == AVPlayer.Status.readyToPlay {
            showPlayer()
        }
    }
    @objc func playerDidPlayEnd(){
        let repeatState = audioPlaying.repeatState
        
        switch repeatState {
        case .OFF:
            if audioPlaying.indexPlaying + 1 <= audioPlaying.originListID.count - 1 {
                goToMusic(next: true)
            } else {
                pauseMusic()
            }
        case .ALL_LIST:
            if audioPlaying.indexPlaying == audioPlaying.originListID.count - 1 {
                goToMusic(index: 0)
            } else if audioPlaying.indexPlaying + 1 < audioPlaying.originListID.count {
                goToMusic(next: true)
            }
        case .ONE:
            audioPlaying.player.seek(to: CMTime(seconds:0, preferredTimescale: 1))
            playMusic()
        }
    }
}

//MARK: Configure hamburger view
extension MiniPlayerViewController {
    
    func toggleHamburgerView() {
        let show = !isShowHamburger
        UIView.animate(withDuration: 0.2) {
            self.hamburgerLeading.constant = CGFloat(show ? 0 : -self.view.frame.width)
            self.view.layoutIfNeeded()
        }
        isShowHamburger = show
    }
    @objc func didTapMainView() {
        if isShowHamburger { toggleHamburgerView() }
    }
}
extension MiniPlayerViewController: DoomVCDelegate {
    func didTapShowButton() {
        toggleHamburgerView()
    }
}
extension MiniPlayerViewController: HamburgerViewDelegate {
    
    func tapBrowse() {
        toggleHamburgerView()
        let browseVC = BrowseViewController()
        browseVC.parentVC = self
        let newVC =  UINavigationController(rootViewController: browseVC)
        addChildVC(vc: newVC)
    }
    
    func tapYourMusic() {
        toggleHamburgerView()
        let yourMusicVC = YourMusicScreen()
        yourMusicVC.parentVC = self
        let newVC =  UINavigationController(rootViewController: yourMusicVC)
        addChildVC(vc: newVC)
    }
    func tapLogOut() {
        UserDefaults.standard.removeObject(forKey: "user_id")
        UserDefaults.standard.removeObject(forKey: "user")
        UserDefaults.standard.removeObject(forKey: "list_song_id")
        AudioPlaying.ins.clearData()
        present(UINavigationController(rootViewController: OpenViewController()), animated: true, completion: nil)
        
    }
}

//MARK: PageView
extension MiniPlayerViewController: UIPageViewControllerDataSource {
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -> UIViewController? {
        guard let index = listVC?.firstIndex(of: viewController) else { return nil }
        return index <= 0 ? nil : listVC![index - 1]
    }
    
    func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -> UIViewController? {
        guard let index = listVC?.firstIndex(of: viewController) else { return nil }
        return index >= listVC!.count - 1 ? nil : listVC![index + 1]
    }
}







import AVKit

class AudioPlaying {
    static var ins = AudioPlaying()
    
    var isPlayerLoaded = false
    var player = AVPlayer()
    var song: Song?
    var originListID: [String] = ["0", "1", "2"]
    var listID: [String] = []
    var indexPlaying = 0
    var isPlaying = false
    var shuffleState = ShuffleState.OFF
    var repeatState = RepeatState.OFF
    var playerItemContext = 0
    var isFavMark = false
    private var isDownloading = false
    
    func setDownloadStatus(isOn: Bool){ isDownloading = isOn }
    func downloadingStatus() -> Bool { return isDownloading }
    
    func currentIDSong() -> String? {
        if listID.count == 0 { return nil }
        return listID[indexPlaying]
    }
    func setUpListID(listID: [String], index: Int){
        self.listID = listID
        self.originListID = listID
        indexPlaying = index
    }
    func setUpPlayer(url: URL, _ completion: @escaping (AVKeyValueStatus) -> Void ){
        let asset = AVAsset(url: url)
        let key: Array = ["playable"]
        asset.loadValuesAsynchronously(forKeys: key) {
            var error: NSError?
            let status = asset.statusOfValue(forKey: "playable", error: &error)
            switch status {
            case .loaded:
                DispatchQueue.main.async {
                    let item = AVPlayerItem(asset: asset)
                    self.player.replaceCurrentItem(with: item)
                    self.player.automaticallyWaitsToMinimizeStalling = false
                    completion(status)
                }
            default: break
            }
            
        }
    }
    func isEndOfListID() -> Bool {
        return (indexPlaying >= originListID.count - 1)  &&  ( player.currentTime() == player.currentItem?.asset.duration )
    }
    func playPlayer(){
        player.play()
        isPlaying = true
        updateMPRemotePlayer()
    }
    func pausePlayer(){
        player.pause()
        isPlaying = false
        updateMPRemotePlayer()
    }
    func stopPlayer(){
        pausePlayer()
        seekToTime(second: 0.0)
        updateMPRemotePlayer()
    }
    func seekToTime(second: Double){
        player.seek(to: CMTime(seconds: second, preferredTimescale: CMTimeScale(1.0)))
        print("At seekToTime: \(player.currentTime().seconds)")
        updateMPRemotePlayer()
    }
    func clearData(){
        song = nil
        shuffleState = ShuffleState.OFF
        repeatState = RepeatState.OFF
        stopPlayer()
    }
    
    //Repeat and shuffle
    func setRepeatState(_ state: RepeatState){
        repeatState = state
    }
    func setShuffleState(_ state: ShuffleState){
        shuffleState = state
    }
    func updateMPRemotePlayer(){
        if song == nil { return }
        var nowPlayingInfo = [String: Any]()
        nowPlayingInfo[MPMediaItemPropertyTitle] = song?.name ?? ""
        let urlImage = song?.imageUrl ?? ""
        let curItem = player.currentItem
        print("At update MPRomote: \(player.currentTime().seconds)")
        nowPlayingInfo[MPNowPlayingInfoPropertyPlaybackRate] = 1
        nowPlayingInfo[MPNowPlayingInfoPropertyElapsedPlaybackTime] = player.currentTime().seconds
        nowPlayingInfo[MPMediaItemPropertyPlaybackDuration] = curItem?.asset.duration.seconds
////        URLSession.shared.dataTask(with: URL(string: urlImage)!) { (data, response, error) in
////            guard let data = data, error == nil else { return }
////            let image = UIImage(data: data) ?? #imageLiteral(resourceName: "ic_playlists_tapped")
////            DispatchQueue.main.async {
////                nowPlayingInfo[MPMediaItemPropertyArtwork] = MPMediaItemArtwork(boundsSize: image.size, requestHandler: { (size) -> UIImage in
////                    return image
////                })
////            }
////        }
        MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo
        
//        MPNowPlayingInfoCenter.default().setValue(player.currentTime().seconds, forKeyPath: MPNowPlayingInfoPropertyElapsedPlaybackTime)
    }
}


protocol MiniPlayerDelegate {
    func didTapPlayButton(isPlaying: Bool)
}
